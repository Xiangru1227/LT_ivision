// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CameraCommunication.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_CameraCommunication_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_CameraCommunication_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_CameraCommunication_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_CameraCommunication_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_CameraCommunication_2eproto;
namespace CameraCommunication {
class Acknowledgement;
struct AcknowledgementDefaultTypeInternal;
extern AcknowledgementDefaultTypeInternal _Acknowledgement_default_instance_;
class Commands;
struct CommandsDefaultTypeInternal;
extern CommandsDefaultTypeInternal _Commands_default_instance_;
class SMRData;
struct SMRDataDefaultTypeInternal;
extern SMRDataDefaultTypeInternal _SMRData_default_instance_;
class VideoData;
struct VideoDataDefaultTypeInternal;
extern VideoDataDefaultTypeInternal _VideoData_default_instance_;
}  // namespace CameraCommunication
PROTOBUF_NAMESPACE_OPEN
template<> ::CameraCommunication::Acknowledgement* Arena::CreateMaybeMessage<::CameraCommunication::Acknowledgement>(Arena*);
template<> ::CameraCommunication::Commands* Arena::CreateMaybeMessage<::CameraCommunication::Commands>(Arena*);
template<> ::CameraCommunication::SMRData* Arena::CreateMaybeMessage<::CameraCommunication::SMRData>(Arena*);
template<> ::CameraCommunication::VideoData* Arena::CreateMaybeMessage<::CameraCommunication::VideoData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace CameraCommunication {

enum MethodId : int {
  CalibrationParameters = 0,
  StartVideo = 1,
  StopVideo = 2,
  GetExposure = 3,
  SetExposure = 4,
  GetDigitalGain = 5,
  SetDigitalGain = 6,
  SetROIVideoStream = 7,
  BroadcastCamera = 8,
  GetAnalogGain = 9,
  SetAnalogGain = 10,
  GetFPS = 11,
  SetFPS = 12,
  GetSensorResolution = 13,
  SetSensorResolution = 14,
  GetDisplayResolution = 15,
  SetDisplayResolution = 16,
  SetOpMode = 17,
  NextSMR = 18,
  UserClick = 19,
  GetVersionNumber = 20,
  MethodId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MethodId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MethodId_IsValid(int value);
constexpr MethodId MethodId_MIN = CalibrationParameters;
constexpr MethodId MethodId_MAX = GetVersionNumber;
constexpr int MethodId_ARRAYSIZE = MethodId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MethodId_descriptor();
template<typename T>
inline const std::string& MethodId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MethodId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MethodId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MethodId_descriptor(), enum_t_value);
}
inline bool MethodId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MethodId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MethodId>(
    MethodId_descriptor(), name, value);
}
enum IVisionOpMode : int {
  Idle = 0,
  SingleSMR = 1,
  MultiSMR = 2,
  ManualSMR = 3,
  Teach2Drive = 4,
  Shake2Drive = 5,
  CamCalibration = 6,
  TrackCalibration = 7,
  IVisionOpMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  IVisionOpMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool IVisionOpMode_IsValid(int value);
constexpr IVisionOpMode IVisionOpMode_MIN = Idle;
constexpr IVisionOpMode IVisionOpMode_MAX = TrackCalibration;
constexpr int IVisionOpMode_ARRAYSIZE = IVisionOpMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* IVisionOpMode_descriptor();
template<typename T>
inline const std::string& IVisionOpMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, IVisionOpMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function IVisionOpMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    IVisionOpMode_descriptor(), enum_t_value);
}
inline bool IVisionOpMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IVisionOpMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<IVisionOpMode>(
    IVisionOpMode_descriptor(), name, value);
}
// ===================================================================

class Commands final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CameraCommunication.Commands) */ {
 public:
  inline Commands() : Commands(nullptr) {}
  ~Commands() override;
  explicit PROTOBUF_CONSTEXPR Commands(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Commands(const Commands& from);
  Commands(Commands&& from) noexcept
    : Commands() {
    *this = ::std::move(from);
  }

  inline Commands& operator=(const Commands& from) {
    CopyFrom(from);
    return *this;
  }
  inline Commands& operator=(Commands&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Commands& default_instance() {
    return *internal_default_instance();
  }
  static inline const Commands* internal_default_instance() {
    return reinterpret_cast<const Commands*>(
               &_Commands_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Commands& a, Commands& b) {
    a.Swap(&b);
  }
  inline void Swap(Commands* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Commands* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Commands* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Commands>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Commands& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Commands& from) {
    Commands::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Commands* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CameraCommunication.Commands";
  }
  protected:
  explicit Commands(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 2,
    kMethodFieldNumber = 1,
    kOpmodeFieldNumber = 3,
  };
  // repeated float parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  float _internal_parameters(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_parameters() const;
  void _internal_add_parameters(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_parameters();
  public:
  float parameters(int index) const;
  void set_parameters(int index, float value);
  void add_parameters(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_parameters();

  // .CameraCommunication.MethodId method = 1;
  void clear_method();
  ::CameraCommunication::MethodId method() const;
  void set_method(::CameraCommunication::MethodId value);
  private:
  ::CameraCommunication::MethodId _internal_method() const;
  void _internal_set_method(::CameraCommunication::MethodId value);
  public:

  // .CameraCommunication.IVisionOpMode opmode = 3;
  void clear_opmode();
  ::CameraCommunication::IVisionOpMode opmode() const;
  void set_opmode(::CameraCommunication::IVisionOpMode value);
  private:
  ::CameraCommunication::IVisionOpMode _internal_opmode() const;
  void _internal_set_opmode(::CameraCommunication::IVisionOpMode value);
  public:

  // @@protoc_insertion_point(class_scope:CameraCommunication.Commands)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > parameters_;
    int method_;
    int opmode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CameraCommunication_2eproto;
};
// -------------------------------------------------------------------

class Acknowledgement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CameraCommunication.Acknowledgement) */ {
 public:
  inline Acknowledgement() : Acknowledgement(nullptr) {}
  ~Acknowledgement() override;
  explicit PROTOBUF_CONSTEXPR Acknowledgement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Acknowledgement(const Acknowledgement& from);
  Acknowledgement(Acknowledgement&& from) noexcept
    : Acknowledgement() {
    *this = ::std::move(from);
  }

  inline Acknowledgement& operator=(const Acknowledgement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Acknowledgement& operator=(Acknowledgement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Acknowledgement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Acknowledgement* internal_default_instance() {
    return reinterpret_cast<const Acknowledgement*>(
               &_Acknowledgement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Acknowledgement& a, Acknowledgement& b) {
    a.Swap(&b);
  }
  inline void Swap(Acknowledgement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Acknowledgement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Acknowledgement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Acknowledgement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Acknowledgement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Acknowledgement& from) {
    Acknowledgement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Acknowledgement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CameraCommunication.Acknowledgement";
  }
  protected:
  explicit Acknowledgement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 3,
    kParameterStringFieldNumber = 4,
    kMethodFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // repeated float parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  float _internal_parameters(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_parameters() const;
  void _internal_add_parameters(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_parameters();
  public:
  float parameters(int index) const;
  void set_parameters(int index, float value);
  void add_parameters(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_parameters();

  // string parameter_string = 4;
  void clear_parameter_string();
  const std::string& parameter_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parameter_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parameter_string();
  PROTOBUF_NODISCARD std::string* release_parameter_string();
  void set_allocated_parameter_string(std::string* parameter_string);
  private:
  const std::string& _internal_parameter_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parameter_string(const std::string& value);
  std::string* _internal_mutable_parameter_string();
  public:

  // .CameraCommunication.MethodId method = 1;
  void clear_method();
  ::CameraCommunication::MethodId method() const;
  void set_method(::CameraCommunication::MethodId value);
  private:
  ::CameraCommunication::MethodId _internal_method() const;
  void _internal_set_method(::CameraCommunication::MethodId value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CameraCommunication.Acknowledgement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > parameters_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parameter_string_;
    int method_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CameraCommunication_2eproto;
};
// -------------------------------------------------------------------

class SMRData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CameraCommunication.SMRData) */ {
 public:
  inline SMRData() : SMRData(nullptr) {}
  ~SMRData() override;
  explicit PROTOBUF_CONSTEXPR SMRData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SMRData(const SMRData& from);
  SMRData(SMRData&& from) noexcept
    : SMRData() {
    *this = ::std::move(from);
  }

  inline SMRData& operator=(const SMRData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SMRData& operator=(SMRData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SMRData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SMRData* internal_default_instance() {
    return reinterpret_cast<const SMRData*>(
               &_SMRData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SMRData& a, SMRData& b) {
    a.Swap(&b);
  }
  inline void Swap(SMRData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SMRData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SMRData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SMRData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SMRData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SMRData& from) {
    SMRData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SMRData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CameraCommunication.SMRData";
  }
  protected:
  explicit SMRData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // repeated float x = 1;
  int x_size() const;
  private:
  int _internal_x_size() const;
  public:
  void clear_x();
  private:
  float _internal_x(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_x() const;
  void _internal_add_x(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_x();
  public:
  float x(int index) const;
  void set_x(int index, float value);
  void add_x(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      x() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_x();

  // repeated float y = 2;
  int y_size() const;
  private:
  int _internal_y_size() const;
  public:
  void clear_y();
  private:
  float _internal_y(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_y() const;
  void _internal_add_y(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_y();
  public:
  float y(int index) const;
  void set_y(int index, float value);
  void add_y(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      y() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_y();

  // @@protoc_insertion_point(class_scope:CameraCommunication.SMRData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > x_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CameraCommunication_2eproto;
};
// -------------------------------------------------------------------

class VideoData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CameraCommunication.VideoData) */ {
 public:
  inline VideoData() : VideoData(nullptr) {}
  ~VideoData() override;
  explicit PROTOBUF_CONSTEXPR VideoData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoData(const VideoData& from);
  VideoData(VideoData&& from) noexcept
    : VideoData() {
    *this = ::std::move(from);
  }

  inline VideoData& operator=(const VideoData& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoData& operator=(VideoData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VideoData& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoData* internal_default_instance() {
    return reinterpret_cast<const VideoData*>(
               &_VideoData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(VideoData& a, VideoData& b) {
    a.Swap(&b);
  }
  inline void Swap(VideoData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VideoData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VideoData& from) {
    VideoData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VideoData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CameraCommunication.VideoData";
  }
  protected:
  explicit VideoData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 1,
    kSmrFieldNumber = 2,
    kTimestampFieldNumber = 4,
    kOpmodeFieldNumber = 3,
  };
  // bytes image = 1;
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // .CameraCommunication.SMRData smr = 2;
  bool has_smr() const;
  private:
  bool _internal_has_smr() const;
  public:
  void clear_smr();
  const ::CameraCommunication::SMRData& smr() const;
  PROTOBUF_NODISCARD ::CameraCommunication::SMRData* release_smr();
  ::CameraCommunication::SMRData* mutable_smr();
  void set_allocated_smr(::CameraCommunication::SMRData* smr);
  private:
  const ::CameraCommunication::SMRData& _internal_smr() const;
  ::CameraCommunication::SMRData* _internal_mutable_smr();
  public:
  void unsafe_arena_set_allocated_smr(
      ::CameraCommunication::SMRData* smr);
  ::CameraCommunication::SMRData* unsafe_arena_release_smr();

  // uint64 timestamp = 4;
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // .CameraCommunication.IVisionOpMode opmode = 3;
  void clear_opmode();
  ::CameraCommunication::IVisionOpMode opmode() const;
  void set_opmode(::CameraCommunication::IVisionOpMode value);
  private:
  ::CameraCommunication::IVisionOpMode _internal_opmode() const;
  void _internal_set_opmode(::CameraCommunication::IVisionOpMode value);
  public:

  // @@protoc_insertion_point(class_scope:CameraCommunication.VideoData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
    ::CameraCommunication::SMRData* smr_;
    uint64_t timestamp_;
    int opmode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_CameraCommunication_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Commands

// .CameraCommunication.MethodId method = 1;
inline void Commands::clear_method() {
  _impl_.method_ = 0;
}
inline ::CameraCommunication::MethodId Commands::_internal_method() const {
  return static_cast< ::CameraCommunication::MethodId >(_impl_.method_);
}
inline ::CameraCommunication::MethodId Commands::method() const {
  // @@protoc_insertion_point(field_get:CameraCommunication.Commands.method)
  return _internal_method();
}
inline void Commands::_internal_set_method(::CameraCommunication::MethodId value) {
  
  _impl_.method_ = value;
}
inline void Commands::set_method(::CameraCommunication::MethodId value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:CameraCommunication.Commands.method)
}

// repeated float parameters = 2;
inline int Commands::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int Commands::parameters_size() const {
  return _internal_parameters_size();
}
inline void Commands::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline float Commands::_internal_parameters(int index) const {
  return _impl_.parameters_.Get(index);
}
inline float Commands::parameters(int index) const {
  // @@protoc_insertion_point(field_get:CameraCommunication.Commands.parameters)
  return _internal_parameters(index);
}
inline void Commands::set_parameters(int index, float value) {
  _impl_.parameters_.Set(index, value);
  // @@protoc_insertion_point(field_set:CameraCommunication.Commands.parameters)
}
inline void Commands::_internal_add_parameters(float value) {
  _impl_.parameters_.Add(value);
}
inline void Commands::add_parameters(float value) {
  _internal_add_parameters(value);
  // @@protoc_insertion_point(field_add:CameraCommunication.Commands.parameters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Commands::_internal_parameters() const {
  return _impl_.parameters_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Commands::parameters() const {
  // @@protoc_insertion_point(field_list:CameraCommunication.Commands.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Commands::_internal_mutable_parameters() {
  return &_impl_.parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Commands::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:CameraCommunication.Commands.parameters)
  return _internal_mutable_parameters();
}

// .CameraCommunication.IVisionOpMode opmode = 3;
inline void Commands::clear_opmode() {
  _impl_.opmode_ = 0;
}
inline ::CameraCommunication::IVisionOpMode Commands::_internal_opmode() const {
  return static_cast< ::CameraCommunication::IVisionOpMode >(_impl_.opmode_);
}
inline ::CameraCommunication::IVisionOpMode Commands::opmode() const {
  // @@protoc_insertion_point(field_get:CameraCommunication.Commands.opmode)
  return _internal_opmode();
}
inline void Commands::_internal_set_opmode(::CameraCommunication::IVisionOpMode value) {
  
  _impl_.opmode_ = value;
}
inline void Commands::set_opmode(::CameraCommunication::IVisionOpMode value) {
  _internal_set_opmode(value);
  // @@protoc_insertion_point(field_set:CameraCommunication.Commands.opmode)
}

// -------------------------------------------------------------------

// Acknowledgement

// .CameraCommunication.MethodId method = 1;
inline void Acknowledgement::clear_method() {
  _impl_.method_ = 0;
}
inline ::CameraCommunication::MethodId Acknowledgement::_internal_method() const {
  return static_cast< ::CameraCommunication::MethodId >(_impl_.method_);
}
inline ::CameraCommunication::MethodId Acknowledgement::method() const {
  // @@protoc_insertion_point(field_get:CameraCommunication.Acknowledgement.method)
  return _internal_method();
}
inline void Acknowledgement::_internal_set_method(::CameraCommunication::MethodId value) {
  
  _impl_.method_ = value;
}
inline void Acknowledgement::set_method(::CameraCommunication::MethodId value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:CameraCommunication.Acknowledgement.method)
}

// bool success = 2;
inline void Acknowledgement::clear_success() {
  _impl_.success_ = false;
}
inline bool Acknowledgement::_internal_success() const {
  return _impl_.success_;
}
inline bool Acknowledgement::success() const {
  // @@protoc_insertion_point(field_get:CameraCommunication.Acknowledgement.success)
  return _internal_success();
}
inline void Acknowledgement::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void Acknowledgement::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:CameraCommunication.Acknowledgement.success)
}

// repeated float parameters = 3;
inline int Acknowledgement::_internal_parameters_size() const {
  return _impl_.parameters_.size();
}
inline int Acknowledgement::parameters_size() const {
  return _internal_parameters_size();
}
inline void Acknowledgement::clear_parameters() {
  _impl_.parameters_.Clear();
}
inline float Acknowledgement::_internal_parameters(int index) const {
  return _impl_.parameters_.Get(index);
}
inline float Acknowledgement::parameters(int index) const {
  // @@protoc_insertion_point(field_get:CameraCommunication.Acknowledgement.parameters)
  return _internal_parameters(index);
}
inline void Acknowledgement::set_parameters(int index, float value) {
  _impl_.parameters_.Set(index, value);
  // @@protoc_insertion_point(field_set:CameraCommunication.Acknowledgement.parameters)
}
inline void Acknowledgement::_internal_add_parameters(float value) {
  _impl_.parameters_.Add(value);
}
inline void Acknowledgement::add_parameters(float value) {
  _internal_add_parameters(value);
  // @@protoc_insertion_point(field_add:CameraCommunication.Acknowledgement.parameters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Acknowledgement::_internal_parameters() const {
  return _impl_.parameters_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Acknowledgement::parameters() const {
  // @@protoc_insertion_point(field_list:CameraCommunication.Acknowledgement.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Acknowledgement::_internal_mutable_parameters() {
  return &_impl_.parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Acknowledgement::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:CameraCommunication.Acknowledgement.parameters)
  return _internal_mutable_parameters();
}

// string parameter_string = 4;
inline void Acknowledgement::clear_parameter_string() {
  _impl_.parameter_string_.ClearToEmpty();
}
inline const std::string& Acknowledgement::parameter_string() const {
  // @@protoc_insertion_point(field_get:CameraCommunication.Acknowledgement.parameter_string)
  return _internal_parameter_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Acknowledgement::set_parameter_string(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parameter_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CameraCommunication.Acknowledgement.parameter_string)
}
inline std::string* Acknowledgement::mutable_parameter_string() {
  std::string* _s = _internal_mutable_parameter_string();
  // @@protoc_insertion_point(field_mutable:CameraCommunication.Acknowledgement.parameter_string)
  return _s;
}
inline const std::string& Acknowledgement::_internal_parameter_string() const {
  return _impl_.parameter_string_.Get();
}
inline void Acknowledgement::_internal_set_parameter_string(const std::string& value) {
  
  _impl_.parameter_string_.Set(value, GetArenaForAllocation());
}
inline std::string* Acknowledgement::_internal_mutable_parameter_string() {
  
  return _impl_.parameter_string_.Mutable(GetArenaForAllocation());
}
inline std::string* Acknowledgement::release_parameter_string() {
  // @@protoc_insertion_point(field_release:CameraCommunication.Acknowledgement.parameter_string)
  return _impl_.parameter_string_.Release();
}
inline void Acknowledgement::set_allocated_parameter_string(std::string* parameter_string) {
  if (parameter_string != nullptr) {
    
  } else {
    
  }
  _impl_.parameter_string_.SetAllocated(parameter_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parameter_string_.IsDefault()) {
    _impl_.parameter_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CameraCommunication.Acknowledgement.parameter_string)
}

// -------------------------------------------------------------------

// SMRData

// repeated float x = 1;
inline int SMRData::_internal_x_size() const {
  return _impl_.x_.size();
}
inline int SMRData::x_size() const {
  return _internal_x_size();
}
inline void SMRData::clear_x() {
  _impl_.x_.Clear();
}
inline float SMRData::_internal_x(int index) const {
  return _impl_.x_.Get(index);
}
inline float SMRData::x(int index) const {
  // @@protoc_insertion_point(field_get:CameraCommunication.SMRData.x)
  return _internal_x(index);
}
inline void SMRData::set_x(int index, float value) {
  _impl_.x_.Set(index, value);
  // @@protoc_insertion_point(field_set:CameraCommunication.SMRData.x)
}
inline void SMRData::_internal_add_x(float value) {
  _impl_.x_.Add(value);
}
inline void SMRData::add_x(float value) {
  _internal_add_x(value);
  // @@protoc_insertion_point(field_add:CameraCommunication.SMRData.x)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SMRData::_internal_x() const {
  return _impl_.x_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SMRData::x() const {
  // @@protoc_insertion_point(field_list:CameraCommunication.SMRData.x)
  return _internal_x();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SMRData::_internal_mutable_x() {
  return &_impl_.x_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SMRData::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:CameraCommunication.SMRData.x)
  return _internal_mutable_x();
}

// repeated float y = 2;
inline int SMRData::_internal_y_size() const {
  return _impl_.y_.size();
}
inline int SMRData::y_size() const {
  return _internal_y_size();
}
inline void SMRData::clear_y() {
  _impl_.y_.Clear();
}
inline float SMRData::_internal_y(int index) const {
  return _impl_.y_.Get(index);
}
inline float SMRData::y(int index) const {
  // @@protoc_insertion_point(field_get:CameraCommunication.SMRData.y)
  return _internal_y(index);
}
inline void SMRData::set_y(int index, float value) {
  _impl_.y_.Set(index, value);
  // @@protoc_insertion_point(field_set:CameraCommunication.SMRData.y)
}
inline void SMRData::_internal_add_y(float value) {
  _impl_.y_.Add(value);
}
inline void SMRData::add_y(float value) {
  _internal_add_y(value);
  // @@protoc_insertion_point(field_add:CameraCommunication.SMRData.y)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SMRData::_internal_y() const {
  return _impl_.y_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SMRData::y() const {
  // @@protoc_insertion_point(field_list:CameraCommunication.SMRData.y)
  return _internal_y();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SMRData::_internal_mutable_y() {
  return &_impl_.y_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SMRData::mutable_y() {
  // @@protoc_insertion_point(field_mutable_list:CameraCommunication.SMRData.y)
  return _internal_mutable_y();
}

// -------------------------------------------------------------------

// VideoData

// bytes image = 1;
inline void VideoData::clear_image() {
  _impl_.image_.ClearToEmpty();
}
inline const std::string& VideoData::image() const {
  // @@protoc_insertion_point(field_get:CameraCommunication.VideoData.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoData::set_image(ArgT0&& arg0, ArgT... args) {
 
 _impl_.image_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CameraCommunication.VideoData.image)
}
inline std::string* VideoData::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:CameraCommunication.VideoData.image)
  return _s;
}
inline const std::string& VideoData::_internal_image() const {
  return _impl_.image_.Get();
}
inline void VideoData::_internal_set_image(const std::string& value) {
  
  _impl_.image_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoData::_internal_mutable_image() {
  
  return _impl_.image_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoData::release_image() {
  // @@protoc_insertion_point(field_release:CameraCommunication.VideoData.image)
  return _impl_.image_.Release();
}
inline void VideoData::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    
  } else {
    
  }
  _impl_.image_.SetAllocated(image, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.image_.IsDefault()) {
    _impl_.image_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CameraCommunication.VideoData.image)
}

// .CameraCommunication.SMRData smr = 2;
inline bool VideoData::_internal_has_smr() const {
  return this != internal_default_instance() && _impl_.smr_ != nullptr;
}
inline bool VideoData::has_smr() const {
  return _internal_has_smr();
}
inline void VideoData::clear_smr() {
  if (GetArenaForAllocation() == nullptr && _impl_.smr_ != nullptr) {
    delete _impl_.smr_;
  }
  _impl_.smr_ = nullptr;
}
inline const ::CameraCommunication::SMRData& VideoData::_internal_smr() const {
  const ::CameraCommunication::SMRData* p = _impl_.smr_;
  return p != nullptr ? *p : reinterpret_cast<const ::CameraCommunication::SMRData&>(
      ::CameraCommunication::_SMRData_default_instance_);
}
inline const ::CameraCommunication::SMRData& VideoData::smr() const {
  // @@protoc_insertion_point(field_get:CameraCommunication.VideoData.smr)
  return _internal_smr();
}
inline void VideoData::unsafe_arena_set_allocated_smr(
    ::CameraCommunication::SMRData* smr) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.smr_);
  }
  _impl_.smr_ = smr;
  if (smr) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CameraCommunication.VideoData.smr)
}
inline ::CameraCommunication::SMRData* VideoData::release_smr() {
  
  ::CameraCommunication::SMRData* temp = _impl_.smr_;
  _impl_.smr_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CameraCommunication::SMRData* VideoData::unsafe_arena_release_smr() {
  // @@protoc_insertion_point(field_release:CameraCommunication.VideoData.smr)
  
  ::CameraCommunication::SMRData* temp = _impl_.smr_;
  _impl_.smr_ = nullptr;
  return temp;
}
inline ::CameraCommunication::SMRData* VideoData::_internal_mutable_smr() {
  
  if (_impl_.smr_ == nullptr) {
    auto* p = CreateMaybeMessage<::CameraCommunication::SMRData>(GetArenaForAllocation());
    _impl_.smr_ = p;
  }
  return _impl_.smr_;
}
inline ::CameraCommunication::SMRData* VideoData::mutable_smr() {
  ::CameraCommunication::SMRData* _msg = _internal_mutable_smr();
  // @@protoc_insertion_point(field_mutable:CameraCommunication.VideoData.smr)
  return _msg;
}
inline void VideoData::set_allocated_smr(::CameraCommunication::SMRData* smr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.smr_;
  }
  if (smr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(smr);
    if (message_arena != submessage_arena) {
      smr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, smr, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.smr_ = smr;
  // @@protoc_insertion_point(field_set_allocated:CameraCommunication.VideoData.smr)
}

// .CameraCommunication.IVisionOpMode opmode = 3;
inline void VideoData::clear_opmode() {
  _impl_.opmode_ = 0;
}
inline ::CameraCommunication::IVisionOpMode VideoData::_internal_opmode() const {
  return static_cast< ::CameraCommunication::IVisionOpMode >(_impl_.opmode_);
}
inline ::CameraCommunication::IVisionOpMode VideoData::opmode() const {
  // @@protoc_insertion_point(field_get:CameraCommunication.VideoData.opmode)
  return _internal_opmode();
}
inline void VideoData::_internal_set_opmode(::CameraCommunication::IVisionOpMode value) {
  
  _impl_.opmode_ = value;
}
inline void VideoData::set_opmode(::CameraCommunication::IVisionOpMode value) {
  _internal_set_opmode(value);
  // @@protoc_insertion_point(field_set:CameraCommunication.VideoData.opmode)
}

// uint64 timestamp = 4;
inline void VideoData::clear_timestamp() {
  _impl_.timestamp_ = uint64_t{0u};
}
inline uint64_t VideoData::_internal_timestamp() const {
  return _impl_.timestamp_;
}
inline uint64_t VideoData::timestamp() const {
  // @@protoc_insertion_point(field_get:CameraCommunication.VideoData.timestamp)
  return _internal_timestamp();
}
inline void VideoData::_internal_set_timestamp(uint64_t value) {
  
  _impl_.timestamp_ = value;
}
inline void VideoData::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CameraCommunication.VideoData.timestamp)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace CameraCommunication

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CameraCommunication::MethodId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraCommunication::MethodId>() {
  return ::CameraCommunication::MethodId_descriptor();
}
template <> struct is_proto_enum< ::CameraCommunication::IVisionOpMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CameraCommunication::IVisionOpMode>() {
  return ::CameraCommunication::IVisionOpMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_CameraCommunication_2eproto
