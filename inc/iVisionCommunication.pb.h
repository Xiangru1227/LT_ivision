// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: iVisionCommunication.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_iVisionCommunication_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_iVisionCommunication_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_iVisionCommunication_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_iVisionCommunication_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_iVisionCommunication_2eproto;
namespace iVisionCommunication {
class Acknowledgement;
struct AcknowledgementDefaultTypeInternal;
extern AcknowledgementDefaultTypeInternal _Acknowledgement_default_instance_;
class BasicCommands;
struct BasicCommandsDefaultTypeInternal;
extern BasicCommandsDefaultTypeInternal _BasicCommands_default_instance_;
class TrackerData;
struct TrackerDataDefaultTypeInternal;
extern TrackerDataDefaultTypeInternal _TrackerData_default_instance_;
}  // namespace iVisionCommunication
PROTOBUF_NAMESPACE_OPEN
template<> ::iVisionCommunication::Acknowledgement* Arena::CreateMaybeMessage<::iVisionCommunication::Acknowledgement>(Arena*);
template<> ::iVisionCommunication::BasicCommands* Arena::CreateMaybeMessage<::iVisionCommunication::BasicCommands>(Arena*);
template<> ::iVisionCommunication::TrackerData* Arena::CreateMaybeMessage<::iVisionCommunication::TrackerData>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace iVisionCommunication {

enum MethodId : int {
  Connect = 0,
  Broadcast = 1,
  MoveBy = 2,
  MoveTo = 3,
  SetPSDLocked = 4,
  SetPSDUnlocked = 5,
  GetPSDLocked = 6,
  SetFlashOffset = 7,
  GetFlashOffset = 8,
  SetFlashDuration = 9,
  GetFlashDuration = 10,
  SetFlashBrightness = 11,
  GetFlashBrightness = 12,
  SetFlashInTKOn = 13,
  SetFlashInTKOff = 14,
  GetFlashInTK = 15,
  SetCamModeOn = 16,
  SetCamModeOff = 17,
  StartSpiral = 18,
  StopSpiral = 19,
  SetSpiral = 20,
  MethodId_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MethodId_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MethodId_IsValid(int value);
constexpr MethodId MethodId_MIN = Connect;
constexpr MethodId MethodId_MAX = SetSpiral;
constexpr int MethodId_ARRAYSIZE = MethodId_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MethodId_descriptor();
template<typename T>
inline const std::string& MethodId_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MethodId>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MethodId_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MethodId_descriptor(), enum_t_value);
}
inline bool MethodId_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MethodId* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MethodId>(
    MethodId_descriptor(), name, value);
}
enum OperationMode : int {
  Idle = 0,
  Servo = 1,
  Track = 2,
  TrackIdle = 3,
  IndexSearch = 4,
  SpiralSearch = 5,
  CameraSearch = 6,
  OperationMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OperationMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OperationMode_IsValid(int value);
constexpr OperationMode OperationMode_MIN = Idle;
constexpr OperationMode OperationMode_MAX = CameraSearch;
constexpr int OperationMode_ARRAYSIZE = OperationMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OperationMode_descriptor();
template<typename T>
inline const std::string& OperationMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OperationMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OperationMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OperationMode_descriptor(), enum_t_value);
}
inline bool OperationMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OperationMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OperationMode>(
    OperationMode_descriptor(), name, value);
}
// ===================================================================

class BasicCommands final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iVisionCommunication.BasicCommands) */ {
 public:
  inline BasicCommands() : BasicCommands(nullptr) {}
  ~BasicCommands() override;
  explicit PROTOBUF_CONSTEXPR BasicCommands(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BasicCommands(const BasicCommands& from);
  BasicCommands(BasicCommands&& from) noexcept
    : BasicCommands() {
    *this = ::std::move(from);
  }

  inline BasicCommands& operator=(const BasicCommands& from) {
    CopyFrom(from);
    return *this;
  }
  inline BasicCommands& operator=(BasicCommands&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BasicCommands& default_instance() {
    return *internal_default_instance();
  }
  static inline const BasicCommands* internal_default_instance() {
    return reinterpret_cast<const BasicCommands*>(
               &_BasicCommands_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(BasicCommands& a, BasicCommands& b) {
    a.Swap(&b);
  }
  inline void Swap(BasicCommands* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BasicCommands* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BasicCommands* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BasicCommands>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BasicCommands& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BasicCommands& from) {
    BasicCommands::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BasicCommands* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iVisionCommunication.BasicCommands";
  }
  protected:
  explicit BasicCommands(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPayloadParametersFieldNumber = 2,
    kMethodFieldNumber = 1,
  };
  // repeated float payload_parameters = 2;
  int payload_parameters_size() const;
  private:
  int _internal_payload_parameters_size() const;
  public:
  void clear_payload_parameters();
  private:
  float _internal_payload_parameters(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_payload_parameters() const;
  void _internal_add_payload_parameters(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_payload_parameters();
  public:
  float payload_parameters(int index) const;
  void set_payload_parameters(int index, float value);
  void add_payload_parameters(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      payload_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_payload_parameters();

  // .iVisionCommunication.MethodId method = 1;
  void clear_method();
  ::iVisionCommunication::MethodId method() const;
  void set_method(::iVisionCommunication::MethodId value);
  private:
  ::iVisionCommunication::MethodId _internal_method() const;
  void _internal_set_method(::iVisionCommunication::MethodId value);
  public:

  // @@protoc_insertion_point(class_scope:iVisionCommunication.BasicCommands)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > payload_parameters_;
    int method_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iVisionCommunication_2eproto;
};
// -------------------------------------------------------------------

class Acknowledgement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iVisionCommunication.Acknowledgement) */ {
 public:
  inline Acknowledgement() : Acknowledgement(nullptr) {}
  ~Acknowledgement() override;
  explicit PROTOBUF_CONSTEXPR Acknowledgement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Acknowledgement(const Acknowledgement& from);
  Acknowledgement(Acknowledgement&& from) noexcept
    : Acknowledgement() {
    *this = ::std::move(from);
  }

  inline Acknowledgement& operator=(const Acknowledgement& from) {
    CopyFrom(from);
    return *this;
  }
  inline Acknowledgement& operator=(Acknowledgement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Acknowledgement& default_instance() {
    return *internal_default_instance();
  }
  static inline const Acknowledgement* internal_default_instance() {
    return reinterpret_cast<const Acknowledgement*>(
               &_Acknowledgement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Acknowledgement& a, Acknowledgement& b) {
    a.Swap(&b);
  }
  inline void Swap(Acknowledgement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Acknowledgement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Acknowledgement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Acknowledgement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Acknowledgement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Acknowledgement& from) {
    Acknowledgement::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Acknowledgement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iVisionCommunication.Acknowledgement";
  }
  protected:
  explicit Acknowledgement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParameterFloatFieldNumber = 4,
    kParameterStringFieldNumber = 3,
    kMethodFieldNumber = 1,
    kSuccessFieldNumber = 2,
  };
  // repeated float parameter_float = 4;
  int parameter_float_size() const;
  private:
  int _internal_parameter_float_size() const;
  public:
  void clear_parameter_float();
  private:
  float _internal_parameter_float(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_parameter_float() const;
  void _internal_add_parameter_float(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_parameter_float();
  public:
  float parameter_float(int index) const;
  void set_parameter_float(int index, float value);
  void add_parameter_float(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      parameter_float() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_parameter_float();

  // string parameter_string = 3;
  void clear_parameter_string();
  const std::string& parameter_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parameter_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parameter_string();
  PROTOBUF_NODISCARD std::string* release_parameter_string();
  void set_allocated_parameter_string(std::string* parameter_string);
  private:
  const std::string& _internal_parameter_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parameter_string(const std::string& value);
  std::string* _internal_mutable_parameter_string();
  public:

  // .iVisionCommunication.MethodId method = 1;
  void clear_method();
  ::iVisionCommunication::MethodId method() const;
  void set_method(::iVisionCommunication::MethodId value);
  private:
  ::iVisionCommunication::MethodId _internal_method() const;
  void _internal_set_method(::iVisionCommunication::MethodId value);
  public:

  // bool success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:iVisionCommunication.Acknowledgement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > parameter_float_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parameter_string_;
    int method_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iVisionCommunication_2eproto;
};
// -------------------------------------------------------------------

class TrackerData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:iVisionCommunication.TrackerData) */ {
 public:
  inline TrackerData() : TrackerData(nullptr) {}
  ~TrackerData() override;
  explicit PROTOBUF_CONSTEXPR TrackerData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TrackerData(const TrackerData& from);
  TrackerData(TrackerData&& from) noexcept
    : TrackerData() {
    *this = ::std::move(from);
  }

  inline TrackerData& operator=(const TrackerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline TrackerData& operator=(TrackerData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TrackerData& default_instance() {
    return *internal_default_instance();
  }
  static inline const TrackerData* internal_default_instance() {
    return reinterpret_cast<const TrackerData*>(
               &_TrackerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TrackerData& a, TrackerData& b) {
    a.Swap(&b);
  }
  inline void Swap(TrackerData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TrackerData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TrackerData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TrackerData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TrackerData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TrackerData& from) {
    TrackerData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrackerData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "iVisionCommunication.TrackerData";
  }
  protected:
  explicit TrackerData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeartBeatFieldNumber = 1,
    kElAngleFieldNumber = 2,
    kAzAngleFieldNumber = 3,
    kDistanceFieldNumber = 4,
    kOpModeFieldNumber = 6,
    kLockedFieldNumber = 5,
    kImgFlagFieldNumber = 7,
    kRefModeFieldNumber = 8,
  };
  // fixed32 heart_beat = 1;
  void clear_heart_beat();
  uint32_t heart_beat() const;
  void set_heart_beat(uint32_t value);
  private:
  uint32_t _internal_heart_beat() const;
  void _internal_set_heart_beat(uint32_t value);
  public:

  // float el_angle = 2;
  void clear_el_angle();
  float el_angle() const;
  void set_el_angle(float value);
  private:
  float _internal_el_angle() const;
  void _internal_set_el_angle(float value);
  public:

  // float az_angle = 3;
  void clear_az_angle();
  float az_angle() const;
  void set_az_angle(float value);
  private:
  float _internal_az_angle() const;
  void _internal_set_az_angle(float value);
  public:

  // float distance = 4;
  void clear_distance();
  float distance() const;
  void set_distance(float value);
  private:
  float _internal_distance() const;
  void _internal_set_distance(float value);
  public:

  // .iVisionCommunication.OperationMode op_mode = 6;
  void clear_op_mode();
  ::iVisionCommunication::OperationMode op_mode() const;
  void set_op_mode(::iVisionCommunication::OperationMode value);
  private:
  ::iVisionCommunication::OperationMode _internal_op_mode() const;
  void _internal_set_op_mode(::iVisionCommunication::OperationMode value);
  public:

  // bool locked = 5;
  void clear_locked();
  bool locked() const;
  void set_locked(bool value);
  private:
  bool _internal_locked() const;
  void _internal_set_locked(bool value);
  public:

  // bool img_flag = 7;
  void clear_img_flag();
  bool img_flag() const;
  void set_img_flag(bool value);
  private:
  bool _internal_img_flag() const;
  void _internal_set_img_flag(bool value);
  public:

  // bool ref_mode = 8;
  void clear_ref_mode();
  bool ref_mode() const;
  void set_ref_mode(bool value);
  private:
  bool _internal_ref_mode() const;
  void _internal_set_ref_mode(bool value);
  public:

  // @@protoc_insertion_point(class_scope:iVisionCommunication.TrackerData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t heart_beat_;
    float el_angle_;
    float az_angle_;
    float distance_;
    int op_mode_;
    bool locked_;
    bool img_flag_;
    bool ref_mode_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_iVisionCommunication_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// BasicCommands

// .iVisionCommunication.MethodId method = 1;
inline void BasicCommands::clear_method() {
  _impl_.method_ = 0;
}
inline ::iVisionCommunication::MethodId BasicCommands::_internal_method() const {
  return static_cast< ::iVisionCommunication::MethodId >(_impl_.method_);
}
inline ::iVisionCommunication::MethodId BasicCommands::method() const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.BasicCommands.method)
  return _internal_method();
}
inline void BasicCommands::_internal_set_method(::iVisionCommunication::MethodId value) {
  
  _impl_.method_ = value;
}
inline void BasicCommands::set_method(::iVisionCommunication::MethodId value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:iVisionCommunication.BasicCommands.method)
}

// repeated float payload_parameters = 2;
inline int BasicCommands::_internal_payload_parameters_size() const {
  return _impl_.payload_parameters_.size();
}
inline int BasicCommands::payload_parameters_size() const {
  return _internal_payload_parameters_size();
}
inline void BasicCommands::clear_payload_parameters() {
  _impl_.payload_parameters_.Clear();
}
inline float BasicCommands::_internal_payload_parameters(int index) const {
  return _impl_.payload_parameters_.Get(index);
}
inline float BasicCommands::payload_parameters(int index) const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.BasicCommands.payload_parameters)
  return _internal_payload_parameters(index);
}
inline void BasicCommands::set_payload_parameters(int index, float value) {
  _impl_.payload_parameters_.Set(index, value);
  // @@protoc_insertion_point(field_set:iVisionCommunication.BasicCommands.payload_parameters)
}
inline void BasicCommands::_internal_add_payload_parameters(float value) {
  _impl_.payload_parameters_.Add(value);
}
inline void BasicCommands::add_payload_parameters(float value) {
  _internal_add_payload_parameters(value);
  // @@protoc_insertion_point(field_add:iVisionCommunication.BasicCommands.payload_parameters)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
BasicCommands::_internal_payload_parameters() const {
  return _impl_.payload_parameters_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
BasicCommands::payload_parameters() const {
  // @@protoc_insertion_point(field_list:iVisionCommunication.BasicCommands.payload_parameters)
  return _internal_payload_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
BasicCommands::_internal_mutable_payload_parameters() {
  return &_impl_.payload_parameters_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
BasicCommands::mutable_payload_parameters() {
  // @@protoc_insertion_point(field_mutable_list:iVisionCommunication.BasicCommands.payload_parameters)
  return _internal_mutable_payload_parameters();
}

// -------------------------------------------------------------------

// Acknowledgement

// .iVisionCommunication.MethodId method = 1;
inline void Acknowledgement::clear_method() {
  _impl_.method_ = 0;
}
inline ::iVisionCommunication::MethodId Acknowledgement::_internal_method() const {
  return static_cast< ::iVisionCommunication::MethodId >(_impl_.method_);
}
inline ::iVisionCommunication::MethodId Acknowledgement::method() const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.Acknowledgement.method)
  return _internal_method();
}
inline void Acknowledgement::_internal_set_method(::iVisionCommunication::MethodId value) {
  
  _impl_.method_ = value;
}
inline void Acknowledgement::set_method(::iVisionCommunication::MethodId value) {
  _internal_set_method(value);
  // @@protoc_insertion_point(field_set:iVisionCommunication.Acknowledgement.method)
}

// bool success = 2;
inline void Acknowledgement::clear_success() {
  _impl_.success_ = false;
}
inline bool Acknowledgement::_internal_success() const {
  return _impl_.success_;
}
inline bool Acknowledgement::success() const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.Acknowledgement.success)
  return _internal_success();
}
inline void Acknowledgement::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void Acknowledgement::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:iVisionCommunication.Acknowledgement.success)
}

// string parameter_string = 3;
inline void Acknowledgement::clear_parameter_string() {
  _impl_.parameter_string_.ClearToEmpty();
}
inline const std::string& Acknowledgement::parameter_string() const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.Acknowledgement.parameter_string)
  return _internal_parameter_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Acknowledgement::set_parameter_string(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parameter_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:iVisionCommunication.Acknowledgement.parameter_string)
}
inline std::string* Acknowledgement::mutable_parameter_string() {
  std::string* _s = _internal_mutable_parameter_string();
  // @@protoc_insertion_point(field_mutable:iVisionCommunication.Acknowledgement.parameter_string)
  return _s;
}
inline const std::string& Acknowledgement::_internal_parameter_string() const {
  return _impl_.parameter_string_.Get();
}
inline void Acknowledgement::_internal_set_parameter_string(const std::string& value) {
  
  _impl_.parameter_string_.Set(value, GetArenaForAllocation());
}
inline std::string* Acknowledgement::_internal_mutable_parameter_string() {
  
  return _impl_.parameter_string_.Mutable(GetArenaForAllocation());
}
inline std::string* Acknowledgement::release_parameter_string() {
  // @@protoc_insertion_point(field_release:iVisionCommunication.Acknowledgement.parameter_string)
  return _impl_.parameter_string_.Release();
}
inline void Acknowledgement::set_allocated_parameter_string(std::string* parameter_string) {
  if (parameter_string != nullptr) {
    
  } else {
    
  }
  _impl_.parameter_string_.SetAllocated(parameter_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parameter_string_.IsDefault()) {
    _impl_.parameter_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:iVisionCommunication.Acknowledgement.parameter_string)
}

// repeated float parameter_float = 4;
inline int Acknowledgement::_internal_parameter_float_size() const {
  return _impl_.parameter_float_.size();
}
inline int Acknowledgement::parameter_float_size() const {
  return _internal_parameter_float_size();
}
inline void Acknowledgement::clear_parameter_float() {
  _impl_.parameter_float_.Clear();
}
inline float Acknowledgement::_internal_parameter_float(int index) const {
  return _impl_.parameter_float_.Get(index);
}
inline float Acknowledgement::parameter_float(int index) const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.Acknowledgement.parameter_float)
  return _internal_parameter_float(index);
}
inline void Acknowledgement::set_parameter_float(int index, float value) {
  _impl_.parameter_float_.Set(index, value);
  // @@protoc_insertion_point(field_set:iVisionCommunication.Acknowledgement.parameter_float)
}
inline void Acknowledgement::_internal_add_parameter_float(float value) {
  _impl_.parameter_float_.Add(value);
}
inline void Acknowledgement::add_parameter_float(float value) {
  _internal_add_parameter_float(value);
  // @@protoc_insertion_point(field_add:iVisionCommunication.Acknowledgement.parameter_float)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Acknowledgement::_internal_parameter_float() const {
  return _impl_.parameter_float_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Acknowledgement::parameter_float() const {
  // @@protoc_insertion_point(field_list:iVisionCommunication.Acknowledgement.parameter_float)
  return _internal_parameter_float();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Acknowledgement::_internal_mutable_parameter_float() {
  return &_impl_.parameter_float_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Acknowledgement::mutable_parameter_float() {
  // @@protoc_insertion_point(field_mutable_list:iVisionCommunication.Acknowledgement.parameter_float)
  return _internal_mutable_parameter_float();
}

// -------------------------------------------------------------------

// TrackerData

// fixed32 heart_beat = 1;
inline void TrackerData::clear_heart_beat() {
  _impl_.heart_beat_ = 0u;
}
inline uint32_t TrackerData::_internal_heart_beat() const {
  return _impl_.heart_beat_;
}
inline uint32_t TrackerData::heart_beat() const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.TrackerData.heart_beat)
  return _internal_heart_beat();
}
inline void TrackerData::_internal_set_heart_beat(uint32_t value) {
  
  _impl_.heart_beat_ = value;
}
inline void TrackerData::set_heart_beat(uint32_t value) {
  _internal_set_heart_beat(value);
  // @@protoc_insertion_point(field_set:iVisionCommunication.TrackerData.heart_beat)
}

// float el_angle = 2;
inline void TrackerData::clear_el_angle() {
  _impl_.el_angle_ = 0;
}
inline float TrackerData::_internal_el_angle() const {
  return _impl_.el_angle_;
}
inline float TrackerData::el_angle() const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.TrackerData.el_angle)
  return _internal_el_angle();
}
inline void TrackerData::_internal_set_el_angle(float value) {
  
  _impl_.el_angle_ = value;
}
inline void TrackerData::set_el_angle(float value) {
  _internal_set_el_angle(value);
  // @@protoc_insertion_point(field_set:iVisionCommunication.TrackerData.el_angle)
}

// float az_angle = 3;
inline void TrackerData::clear_az_angle() {
  _impl_.az_angle_ = 0;
}
inline float TrackerData::_internal_az_angle() const {
  return _impl_.az_angle_;
}
inline float TrackerData::az_angle() const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.TrackerData.az_angle)
  return _internal_az_angle();
}
inline void TrackerData::_internal_set_az_angle(float value) {
  
  _impl_.az_angle_ = value;
}
inline void TrackerData::set_az_angle(float value) {
  _internal_set_az_angle(value);
  // @@protoc_insertion_point(field_set:iVisionCommunication.TrackerData.az_angle)
}

// float distance = 4;
inline void TrackerData::clear_distance() {
  _impl_.distance_ = 0;
}
inline float TrackerData::_internal_distance() const {
  return _impl_.distance_;
}
inline float TrackerData::distance() const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.TrackerData.distance)
  return _internal_distance();
}
inline void TrackerData::_internal_set_distance(float value) {
  
  _impl_.distance_ = value;
}
inline void TrackerData::set_distance(float value) {
  _internal_set_distance(value);
  // @@protoc_insertion_point(field_set:iVisionCommunication.TrackerData.distance)
}

// bool locked = 5;
inline void TrackerData::clear_locked() {
  _impl_.locked_ = false;
}
inline bool TrackerData::_internal_locked() const {
  return _impl_.locked_;
}
inline bool TrackerData::locked() const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.TrackerData.locked)
  return _internal_locked();
}
inline void TrackerData::_internal_set_locked(bool value) {
  
  _impl_.locked_ = value;
}
inline void TrackerData::set_locked(bool value) {
  _internal_set_locked(value);
  // @@protoc_insertion_point(field_set:iVisionCommunication.TrackerData.locked)
}

// .iVisionCommunication.OperationMode op_mode = 6;
inline void TrackerData::clear_op_mode() {
  _impl_.op_mode_ = 0;
}
inline ::iVisionCommunication::OperationMode TrackerData::_internal_op_mode() const {
  return static_cast< ::iVisionCommunication::OperationMode >(_impl_.op_mode_);
}
inline ::iVisionCommunication::OperationMode TrackerData::op_mode() const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.TrackerData.op_mode)
  return _internal_op_mode();
}
inline void TrackerData::_internal_set_op_mode(::iVisionCommunication::OperationMode value) {
  
  _impl_.op_mode_ = value;
}
inline void TrackerData::set_op_mode(::iVisionCommunication::OperationMode value) {
  _internal_set_op_mode(value);
  // @@protoc_insertion_point(field_set:iVisionCommunication.TrackerData.op_mode)
}

// bool img_flag = 7;
inline void TrackerData::clear_img_flag() {
  _impl_.img_flag_ = false;
}
inline bool TrackerData::_internal_img_flag() const {
  return _impl_.img_flag_;
}
inline bool TrackerData::img_flag() const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.TrackerData.img_flag)
  return _internal_img_flag();
}
inline void TrackerData::_internal_set_img_flag(bool value) {
  
  _impl_.img_flag_ = value;
}
inline void TrackerData::set_img_flag(bool value) {
  _internal_set_img_flag(value);
  // @@protoc_insertion_point(field_set:iVisionCommunication.TrackerData.img_flag)
}

// bool ref_mode = 8;
inline void TrackerData::clear_ref_mode() {
  _impl_.ref_mode_ = false;
}
inline bool TrackerData::_internal_ref_mode() const {
  return _impl_.ref_mode_;
}
inline bool TrackerData::ref_mode() const {
  // @@protoc_insertion_point(field_get:iVisionCommunication.TrackerData.ref_mode)
  return _internal_ref_mode();
}
inline void TrackerData::_internal_set_ref_mode(bool value) {
  
  _impl_.ref_mode_ = value;
}
inline void TrackerData::set_ref_mode(bool value) {
  _internal_set_ref_mode(value);
  // @@protoc_insertion_point(field_set:iVisionCommunication.TrackerData.ref_mode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace iVisionCommunication

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::iVisionCommunication::MethodId> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iVisionCommunication::MethodId>() {
  return ::iVisionCommunication::MethodId_descriptor();
}
template <> struct is_proto_enum< ::iVisionCommunication::OperationMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::iVisionCommunication::OperationMode>() {
  return ::iVisionCommunication::OperationMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_iVisionCommunication_2eproto
